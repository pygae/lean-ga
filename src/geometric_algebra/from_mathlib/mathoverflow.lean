import data.mv_polynomial.comm_ring
import linear_algebra.finsupp
import linear_algebra.clifford_algebra.basic
import data.zmod.basic
import data.matrix.notation
import field_theory.mv_polynomial
import tactic.induction
import algebra.char_p.quotient
import data.nat.prime
import algebra.char_p.pi
import algebra.char_p.two
import ring_theory.mv_polynomial.ideal
import ring_theory.mv_polynomial.basic
import algebra.char_p.algebra
import tactic.norm_fin
/-!
A formalization of https://mathoverflow.net/questions/60596/clifford-pbw-theorem-for-quadratic-form/87958#87958

Some Zulip discussion at https://leanprover.zulipchat.com/#narrow/stream/113489-new-members/topic/.F0.9D.94.BD.E2.82.82.5B.CE.B1.2C.20.CE.B2.2C.20.CE.B3.5D.20.2F.20.28.CE.B1.C2.B2.2C.20.CE.B2.C2.B2.2C.20.CE.B3.C2.B2.29/near/222716333.
-/

noncomputable theory

open_locale big_operators

section for_mathlib

lemma ideal.comap_span_le {R : Type*} {S : Type*} [semiring R] [semiring S] (f : S ‚Üí+* R)
  (g : R ‚Üí+* S) (h : function.left_inverse g f) (s : set R) :
  ideal.comap f (ideal.span s) ‚â§ ideal.span (g '' s) :=
begin
  rintros x (hx : f x ‚àà ideal.span s),
  have := ideal.apply_coe_mem_map g _ ‚ü®_, hx‚ü©,
  rw [ideal.map_span, subtype.coe_mk, h x] at this,
  exact this,
end

/-- `char_p.quotient'` as an `iff`. -/
lemma char_p.quotient_iff' (R : Type*) [comm_ring R] (n : ‚Ñï) [char_p R n] (I : ideal R) :
  char_p (R ‚ß∏ I) n ‚Üî ‚àÄ x : ‚Ñï, ‚Üëx ‚àà I ‚Üí (x : R) = 0 :=
begin
  refine ‚ü®Œª (i : char_p (R ‚ß∏ I) n) x hx, _, char_p.quotient' n I‚ü©,
  resetI,
  have := char_p.cast_eq_zero_iff (R ‚ß∏ I) n,
  rw char_p.cast_eq_zero_iff R n,
  refine (this _).mp _,
  exact (submodule.quotient.mk_eq_zero I).mpr hx,
end

lemma ideal.span_le_bot {R : Type*} [semiring R] (s : set R) : ideal.span s ‚â§ ‚ä• ‚Üî s ‚â§ {0} :=
submodule.span_le

/-- `char_p.quotient'` as an `iff`. -/
lemma char_p.quotient_iff'' (R : Type*) [comm_ring R] (n : ‚Ñï) [char_p R n] (I : ideal R) :
  char_p (R ‚ß∏ I) n ‚Üî I.comap (nat.cast_ring_hom R) ‚â§ (nat.cast_ring_hom R).ker :=
(char_p.quotient_iff' _ _ _).trans begin
  rw ring_hom.ker_eq_comap_bot,
  exact iff.rfl,
end

lemma finsupp.equiv_fun_on_finite_const {Œ± Œ≤} [fintype Œ±] [add_comm_monoid Œ≤] (b : Œ≤):
  finsupp.equiv_fun_on_finite.symm (Œª _, b : Œ± ‚Üí Œ≤) = ‚àë i : Œ±, finsupp.single i b :=
by { ext, simp [finsupp.finset_sum_apply] }

-- note; more general than `mv_polynomial.support_smul`
lemma _root_.mv_polynomial.support_smul' {S R œÉ} [comm_semiring R] [monoid S] [distrib_mul_action S R]
  {r : S} {p : mv_polynomial œÉ R} :
  (r ‚Ä¢ p).support ‚äÜ p.support := finsupp.support_smul

lemma finsupp.to_multiset_sup {Œ±} [decidable_eq Œ±] (f g : Œ± ‚Üí‚ÇÄ ‚Ñï) :
  (f ‚äî g).to_multiset = f.to_multiset ‚à™ g.to_multiset :=
begin
  ext,
  simp_rw [multiset.count_union, finsupp.count_to_multiset, finsupp.sup_apply, sup_eq_max],
end

lemma finsupp.to_multiset_inf {Œ±} [decidable_eq Œ±] (f g : Œ± ‚Üí‚ÇÄ ‚Ñï) :
  (f ‚äì g).to_multiset = f.to_multiset ‚à© g.to_multiset :=
begin
  ext,
  simp_rw [multiset.count_inter, finsupp.count_to_multiset, finsupp.inf_apply, inf_eq_min],
end

/-- `equiv.ulift` as a `linear_equiv`. -/
@[simps]
def {w u v} linear_equiv.ulift
  (R : Type u) (M : Type v) [semiring R] [add_comm_monoid M] [module R M]: ulift.{w} M ‚âÉ‚Çó[R] M :=
{ map_add' := Œª x y, rfl,
  map_smul' := Œª c x, rfl,
  .. equiv.ulift }

lemma ideal.mem_span_range_iff_exists_fun {Œπ R} [fintype Œπ] [comm_semiring R] (g : Œπ ‚Üí R) (x : R) :
  x ‚àà ideal.span (set.range g) ‚Üî ‚àÉ f : Œπ ‚Üí R, ‚àë i, f i * g i = x :=
mem_span_range_iff_exists_fun _

instance ulift.algebra' {R A} [comm_semiring R] [semiring A] [algebra R A] : algebra (ulift R) A :=
{ to_fun := Œª r, algebra_map R A r.down,
  commutes' := Œª r x, algebra.commutes r.down x,
  smul_def' := Œª r x, algebra.smul_def' r.down x,
  .. ulift.module,
  .. (algebra_map R A).comp (ulift.ring_equiv : ulift R ‚âÉ+* R).to_ring_hom }

end for_mathlib

namespace q60596

open mv_polynomial

/-- The monomial ideal generated by terms of the form $x_ix_i$. -/
def k_ideal : ideal (mv_polynomial (fin 3) (zmod 2)) :=
ideal.span (set.range (Œª i, (X i * X i : mv_polynomial (fin 3) (zmod 2))))

lemma mem_k_ideal_iff (x : mv_polynomial (fin 3) (zmod 2)) :
  x ‚àà k_ideal ‚Üî ‚àÄ (m : fin 3 ‚Üí‚ÇÄ ‚Ñï), m ‚àà x.support ‚Üí ‚àÉ i, 2 ‚â§ m i :=
begin
  have : k_ideal =
    ideal.span ((Œª i, monomial i (1 : zmod 2)) '' set.range (Œª i, finsupp.single i 2)),
  { simp_rw [k_ideal, X, monomial_mul, one_mul, ‚Üêfinsupp.single_add, ‚Üêset.range_comp] },
  rw [this, mem_ideal_span_monomial_image],
  simp,
end

lemma X0_X1_X2_nmem_k_ideal : (X 0 * X 1 * X 2 : mv_polynomial (fin 3) (zmod 2)) ‚àâ k_ideal :=
begin
  intro h,
  simp_rw [mem_k_ideal_iff, support_mul_X, support_X, finset.map_singleton,
    add_right_embedding_apply, finset.mem_singleton, forall_eq,
    ‚Üêfin.sum_univ_three (Œª i, finsupp.single i 1), ‚Üêfinsupp.equiv_fun_on_finite_const,
    finsupp.equiv_fun_on_finite_symm_apply_to_fun] at h,
  obtain ‚ü®i, hi‚ü© := h,
  revert hi,
  dec_trivial,
end

lemma mul_self_mem_k_ideal_of_X0_X1_X2_mul_mem {x : mv_polynomial (fin 3) (zmod 2)}
  (h : X 0 * X 1 * X 2 * x ‚àà k_ideal) : x * x ‚àà k_ideal :=
begin
  rw mem_k_ideal_iff at h,
  have : x ‚àà ideal.span ((X : fin 3 ‚Üí mv_polynomial _ (zmod 2)) '' set.univ),
  { rw [mem_ideal_span_X_image],
    intros m hm,
    simp_rw [mul_assoc, support_X_mul, finset.map_map, finset.mem_map,
        function.embedding.trans_apply, add_left_embedding_apply, exists_prop,
        forall_exists_index, and_imp, forall_apply_eq_imp_iff‚ÇÇ, ‚Üêadd_assoc,
        ‚Üêfin.sum_univ_three (Œª i, finsupp.single i 1), ‚Üêfinsupp.equiv_fun_on_finite_const,
        finsupp.add_apply, finsupp.equiv_fun_on_finite_symm_apply_to_fun] at h,
    refine (h _ hm).imp (Œª i hi, ‚ü®set.mem_univ _, _‚ü©),
    rintro hmi,
    rw hmi at hi,
    cases nat.le_of_add_le_add_left hi },
  rw [as_sum x, char_two.sum_mul_self],
  refine sum_mem (Œª m hm, _),
  rw [mem_k_ideal_iff, monomial_mul],
  intros m' hm',
  obtain rfl := finset.mem_singleton.1 (support_monomial_subset hm'),
  rw mem_ideal_span_X_image at this,
  obtain ‚ü®i, _, hi‚ü© := this m hm,
  refine ‚ü®i, nat.add_le_add _ _‚ü©; rwa nat.one_le_iff_ne_zero,
end

-- ùîΩ‚ÇÇ[Œ±, Œ≤, Œ≥] / (Œ±¬≤, Œ≤¬≤, Œ≥¬≤)
@[derive [comm_ring, comm_semiring, ring, semiring, add_comm_group, add_comm_monoid]]
def k := _ ‚ß∏ k_ideal

lemma comap_C_span_le_bot :
  k_ideal.comap (C : zmod 2 ‚Üí+* (mv_polynomial (fin 3) (zmod 2))) ‚â§ ‚ä• :=
begin
  refine (ideal.comap_span_le _ _ (constant_coeff_C _) _).trans _,
  refine (ideal.span_le_bot _).2 _,
  rintro x ‚ü®_, ‚ü®i, rfl‚ü©, rfl‚ü©,
  rw [ring_hom.map_mul, constant_coeff_X, mul_zero, set.mem_singleton_iff],
end

/-- `k` has characteristic 2. -/
instance k.char_p : char_p k 2 :=
begin
  dunfold k,
  rw char_p.quotient_iff'',
  have : (nat.cast_ring_hom (mv_polynomial (fin 3) (zmod 2))) = C.comp (nat.cast_ring_hom _),
  { ext1 r, refl },
  rw [this, ‚Üêideal.comap_comap, ‚Üêring_hom.comap_ker],
  exact ideal.comap_mono (comap_C_span_le_bot.trans bot_le),
end

abbreviation Œ± : k := ideal.quotient.mk _ (mv_polynomial.X 0)
abbreviation Œ≤ : k := ideal.quotient.mk _ (mv_polynomial.X 1)
abbreviation Œ≥ : k := ideal.quotient.mk _ (mv_polynomial.X 2)

/-- The elements above square to zero -/
@[simp] lemma X_sq (i : fin 3) :
  ideal.quotient.mk _ (mv_polynomial.X i) * ideal.quotient.mk _ (mv_polynomial.X i) = (0 : k) :=
begin
  change ideal.quotient.mk _ _ = _,
  rw [ideal.quotient.eq_zero_iff_mem],
  exact ideal.subset_span ‚ü®i, rfl‚ü©,
end

/-- If an element multiplied by `Œ±Œ≤Œ≥` is zero then it squares to zero. -/
lemma sq_zero_of_Œ±Œ≤Œ≥_mul {x : k} : Œ± * Œ≤ * Œ≥ * x = 0 ‚Üí x * x = 0 :=
begin
  induction x using quotient.induction_on',
  change ideal.quotient.mk _ _ = 0 ‚Üí ideal.quotient.mk _ _ = 0,
  rw [ideal.quotient.eq_zero_iff_mem, ideal.quotient.eq_zero_iff_mem],
  exact mul_self_mem_k_ideal_of_X0_X1_X2_mul_mem,
end

/-- Though `Œ±Œ≤Œ≥` is not itself zero-/
lemma Œ±Œ≤Œ≥_ne_zero : Œ± * Œ≤ * Œ≥ ‚â† 0 :=
Œª h, X0_X1_X2_nmem_k_ideal $ ideal.quotient.eq_zero_iff_mem.1 h

@[simps]
def L_func : (fin 3 ‚Üí k) ‚Üí‚Çó[k] k :=
Œ± ‚Ä¢ linear_map.proj 0 - Œ≤ ‚Ä¢ linear_map.proj 1 - Œ≥ ‚Ä¢ linear_map.proj 2

/-- The quotient of k^3 by the specified relation-/
@[derive [add_comm_group, module k]]
def L := _ ‚ß∏ L_func.ker

def sq {Œπ R : Type*} [comm_ring R] (i : Œπ) : quadratic_form R (Œπ ‚Üí R) :=
quadratic_form.sq.comp $ linear_map.proj i

lemma sq_map_add_char_two {Œπ R : Type*} [comm_ring R] [char_p R 2] (i : Œπ) (a b : Œπ ‚Üí R) :
  sq i (a + b) = sq i a + sq i b :=
char_two.add_mul_self _ _

lemma sq_map_sub_char_two {Œπ R : Type*} [comm_ring R] [char_p R 2] (i : Œπ) (a b : Œπ ‚Üí R) :
  sq i (a - b) = sq i a - sq i b :=
begin
  haveI : nonempty Œπ := ‚ü®i‚ü©,
  rw [char_two.sub_eq_add, char_two.sub_eq_add, sq_map_add_char_two]
end

open_locale big_operators

/-- The quadratic form (metric) is just euclidean -/
def Q' : quadratic_form k (fin 3 ‚Üí k) :=
‚àë i, sq i

def Q'_add (x y : fin 3 ‚Üí k) : Q' (x + y) = Q' x + Q' y :=
by simp only [Q', quadratic_form.sum_apply, sq_map_add_char_two, finset.sum_add_distrib]

def Q'_sub (x y : fin 3 ‚Üí k) : Q' (x - y) = Q' x - Q' y :=
by simp only [Q', quadratic_form.sum_apply, sq_map_sub_char_two, finset.sum_sub_distrib]

lemma Q'_apply (a : fin 3 ‚Üí k) : Q' a = a 0 * a 0 + a 1 * a 1 + a 2 * a 2 :=
calc Q' a = a 0 * a 0 + (a 1 * a 1 + (a 2 * a 2 + 0)) : rfl
      ... = _ : by ring

lemma Q'_apply_single (i : fin 3) (x : k) : Q' (pi.single i x) = x * x :=
calc Q' (pi.single i x)
    = ‚àë j : fin 3, (pi.single i x * pi.single i x : fin 3 ‚Üí k) j : by simp [Q', sq]
... = _ : by simp_rw [‚Üêpi.single_mul, finset.sum_pi_single', finset.mem_univ, if_pos]

lemma Q'_zero_under_ideal (v : fin 3 ‚Üí k) (hv : v ‚àà L_func.ker) : Q' v = 0 :=
begin
  rw [linear_map.mem_ker, L_func_apply] at hv,
  have h0 : Œ± * Œ≤ * Œ≥ * v 0 = 0,
  { have := congr_arg ((*) (Œ≤ * Œ≥)) hv,
    simp only [mul_zero, mul_add, ‚Üêmul_assoc] at this,
    rw [mul_comm (Œ≤ * Œ≥) Œ±, ‚Üêmul_assoc, mul_right_comm Œ≤ Œ≥ Œ≤, mul_assoc Œ≤ Œ≥ Œ≥, X_sq, X_sq] at this,
    simpa only [mul_zero, zero_mul, add_zero, zero_add] using this },
  have h1 : Œ± * Œ≤ * Œ≥ * v 1 = 0,
  { have := congr_arg ((*) (Œ± * Œ≥)) hv,
    simp only [mul_zero, mul_add, ‚Üêmul_assoc] at this,
    rw [mul_right_comm Œ± Œ≥ Œ±, mul_assoc Œ± Œ≥ Œ≥, mul_right_comm Œ± Œ≥ Œ≤, X_sq, X_sq] at this,
    simpa only [mul_zero, zero_mul, add_zero, zero_add] using this },
  have h2 : Œ± * Œ≤ * Œ≥ * v 2 = 0,
  { have := congr_arg ((*) (Œ± * Œ≤)) hv,
    simp only [mul_zero, mul_add, ‚Üêmul_assoc] at this,
    rw [mul_right_comm Œ± Œ≤ Œ±, mul_assoc Œ± Œ≤ Œ≤, X_sq, X_sq] at this,
    simpa only [mul_zero, zero_mul, add_zero, zero_add] using this },
  rw [Q'_apply, sq_zero_of_Œ±Œ≤Œ≥_mul h0, sq_zero_of_Œ±Œ≤Œ≥_mul h1, sq_zero_of_Œ±Œ≤Œ≥_mul h2,
    add_zero, add_zero],
end

/-- `Q'`, lifted to operate on the quotient space `L`. -/
@[simps]
def Q : quadratic_form k L :=
quadratic_form.of_polar
  (Œª x, quotient.lift_on' x Q' $ Œª a b h, begin
    rw submodule.quotient_rel_r_def at h,
    suffices : Q' (a - b) = 0,
    { rwa [Q'_sub, sub_eq_zero] at this, },
    apply Q'_zero_under_ideal (a - b) h,
  end)
  (Œª a x, begin
    induction x using quotient.induction_on,
    exact Q'.to_fun_smul a x,
  end)
  (by { rintros ‚ü®x‚ü© ‚ü®x'‚ü© ‚ü®y‚ü©, exact Q'.polar_add_left x x' y })
  (by { rintros c ‚ü®x‚ü© ‚ü®y‚ü©, exact Q'.polar_smul_left c x y })

open clifford_algebra

/-! Shorthand for basis vectors in the Clifford algebra -/
abbreviation x' : clifford_algebra Q := Œπ Q $ submodule.quotient.mk (pi.single 0 1)
abbreviation y' : clifford_algebra Q := Œπ Q $ submodule.quotient.mk (pi.single 1 1)
abbreviation z' : clifford_algebra Q := Œπ Q $ submodule.quotient.mk (pi.single 2 1)

/-- The basis vectors square to one -/
@[simp] lemma x_mul_x : x' * x' = 1 :=
begin
  dunfold x',
  simp_rw [clifford_algebra.Œπ_sq_scalar, Q_apply, ‚Üêsubmodule.quotient.mk'_eq_mk,
    quotient.lift_on'_mk', Q'_apply_single, mul_one, map_one],
end

/-- By virtue of the quotient, terms of this form are zero -/
lemma quot_obv : Œ± ‚Ä¢ x' - Œ≤ ‚Ä¢ y' - Œ≥ ‚Ä¢ z' = 0 :=
begin
  dunfold x' y' z',
  simp only [‚Üêlinear_map.map_smul, ‚Üêlinear_map.map_sub, ‚Üêsubmodule.quotient.mk_smul,
    ‚Üêsubmodule.quotient.mk_sub],
  convert linear_map.map_zero _ using 2,
  rw submodule.quotient.mk_eq_zero,
  norm_num [sub_zero, ideal.span, pi.single_apply],
end

/-- The core of the proof - scaling `1` by `Œ± * Œ≤ * Œ≥` gives zero -/
lemma Œ±Œ≤Œ≥_smul_eq_zero : (Œ± * Œ≤ * Œ≥) ‚Ä¢ (1 : clifford_algebra Q) = 0 :=
begin
  suffices : Œ± ‚Ä¢ 1 - Œ≤ ‚Ä¢ (y' * x') - Œ≥ ‚Ä¢ (z' * x') = 0,
  { have := congr_arg (Œª x, (Œ≤ * Œ≥) ‚Ä¢ x) this,
    simpa [smul_sub, smul_smul, mul_assoc Œ≤ Œ≥ Œ≥, mul_right_comm Œ≤ Œ≥ Œ≤, mul_right_comm Œ≤ Œ≥ Œ±,
      mul_comm Œ≤ Œ±] using this },
  have : (Œ± ‚Ä¢ x' - Œ≤ ‚Ä¢ y' - Œ≥ ‚Ä¢ z') * x' = Œ± ‚Ä¢ 1 - Œ≤ ‚Ä¢ (y' * x') - Œ≥ ‚Ä¢ (z' * x'),
  { simp [sub_mul], },
  rw ‚Üê this,
  rw [quot_obv, zero_mul],
end

/-- Our final result -/
lemma algebra_map_not_injective : ¬¨function.injective (algebra_map k $ clifford_algebra Q) :=
Œª h, Œ±Œ≤Œ≥_ne_zero $ h begin
  rw [algebra.algebra_map_eq_smul_one, ring_hom.map_zero, Œ±Œ≤Œ≥_smul_eq_zero],
end

end q60596

/- The generate statement: not every Clifford algebra has an injective algebra map -/
-- TODO: https://github.com/leanprover-community/mathlib/pull/18644/files
lemma {u v} clifford_algebra.not_forall_algebra_map_injective :
  ¬¨‚àÄ (R : Type u) (M : Type v) [comm_ring R] [add_comm_group M], by exactI
   ‚àÄ [module R M], by exactI
   ‚àÄ (Q : quadratic_form R M),
    function.injective (algebra_map R $ clifford_algebra Q) :=
Œª h, q60596.algebra_map_not_injective $ Œª x y hxy, begin
  let f := (linear_equiv.ulift.{u} q60596.k q60596.k).symm.to_linear_map.restrict_scalars (ulift.{u} q60596.k),
  let uQ := (q60596.Q.comp (linear_equiv.ulift q60596.k _).to_linear_map),
  let uQ := linear_map.comp_quadratic_form f uQ,
  have := h (ulift q60596.k) (ulift q60596.L) uQ,
  let uC := clifford_algebra.map q60596.Q uQ
    (linear_equiv.ulift q60596.k q60596.L).symm.to_linear_map (Œª _, rfl),
  simpa using uC.congr_arg hxy,
end

#check linear_map.comp_quadratic_form